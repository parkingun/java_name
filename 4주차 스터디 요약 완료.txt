4주차

ArrayList 클래스 사용하기
 배열은 길이를 정하고 시작해야 하는 단점이 있어서 ArrayList를 사용한다. add()메서드를 이용해 배열의 크기를 더 키울 수도 있고, 배열 중간의 어떤 요소 값이 제거되면 그 다음 요소 값을 하나씩 앞으로 이동하는 코드도 이미 구현되어 있다.
  ArrayList<E> 배열 이름 = new ArrayList<E>();
  ex) ArrayList<Book> library = new ArrayList<Book>();

상속이란?
 B클래스가 A클래스를 상속받으면, B클래스는 A클래스의 멤버 변수와 메서드를 사용할 수 있음.

* B클래스 -> A클래스 (화살표 주의!)
 - A클래스가 B클래스에게 상속한다.

B클래스가 A클래스를 상속받는다.
 - class B extends A { ...

* 예약어 private와 protected의 차이
 둘 다 외부에서 사용할 순 없지만, protected는 하위 클래스에서는 public처럼 사용할 수 있음.


하위 클래스가 생성되는 과정
 1) 상위 클래스를 상속받은 하위 클래스가 생설 될 때는 반드시 상위 클래스의 생성자가 먼저 호출 된다.
 2) 하위 클래스에서 자동으로 super()을 호출
 3) 상위 클래스 생성자가 호출 될 때 상위 클래스의 멤버 변수가 메모리에 생성이 됨.


super 예약어
 - 하위 클래스에서 상위 클래스 접근할 때 사용.
 - 상위 클래스의 디폴트 생성자가 호출 됨.
 - 매개변수 있는 생성자 호출하기
 - super(매개변수, 매개변수)로 직접 호출해줘야 한다.

상위 클래스로 묵시적 클래스 형 변환
 - 가능한 경우 Ex) Customer vc = new VIPCustomer();
   Customer -> 선언된 클래스형 (상위 클래스형)
   VIPCustomer -> 생성된 인스턴스의 클래스형 (하위 클래스형)
   이 때, 이 vc는 선언한 클래스형에 기반하여 멤버 변수와 메서드에 접근할 수 있다. (Customer 클래스의 멤버뿐이다.)

메서드 오버라이딩(method overriding)
 - 상위 클래스에 정의한 메서드가 하위 클래스에서 재정의하는 것을 메서드 오버라이딩.
 - 반환형, 메서드 이름, 매개변수 개수, 매개변수 자료형이 반드시 같아야한다!
 - @Override => 애노테이션(주석)은 '이 메서드는 재정의된 메서드입니다.'라고 컴파일러에 명확히 알려 주는 역할을 한다.

 
묵시적 클래스형 + 메서드 오버라이딩
 - Customer vc = new VIPCustomer(10030, "나몰라", 2000); //VIPCustomer 인스턴스를 Customer형으로 변환
 - 위 경우 원래 Customer형 메서드가 호출 되는 것이 맞지만, 호출 할 함수가 재정의 된 경우 가상 메서드 방식에 의해 VIPCustomer 인스턴스의 메서드가 호출됩니다.

다형성
 - 하나의 코드가 여러 자료형으로 구현되어 실행되는 것!

다운 캐스팅
 Animal ani = new Human(); 
 생성된 인스턴스 Human은 Animal형입니다. 이렇게 Animal로 형 변환이 이루어진 경우 Animal 클래스에서 선언한 메서드와 멤버 변수만 사용할 수 있다. 따라서 다시 Human형으로 되돌아가야하는 경우에 하위 클래스로 다시 자료형을 변환하는 것을 다운 캐스팅이라고 합니다

추상 메서드
 - 함수 몸체가 없이 선언만 하는 메서드
 - abstract int add(int x, int y); //abstract 예약어를 사용

추상클래스를 만드는 이유
 - 추상 클래스는 인스턴스로 생성할 수 없다.
 - 추상 클래스는 상속을 하기 위해 만든 클래스입니다. 하위 클래스에서도 사용할 메서드를 구현하고, 하위 클래스에서 내용을 각각 다르게 구현해야 한다면, 구현 내용을 추상 메서드로 남겨둡니다.
 
템플릿 메서드
 실행 순서, 즉 시나리오를 정의한 메서드이므로 바뀔 수 없다. 그래서 메서드 앞에 예약어 final을 사용해서 선언!
 상속받은 하위 클래스가 메서드를 재정의할 수 없다.

final 예약어
 변수에서는 상수를 의미, 메서드에서는 하위 클래스에서 재정의할 수 없음을 의미, 클래스에서는 상속할 수 없음을 의미.

인터페이스
 - 구현 코드가 없는 인터페이스! 인터페이스는 추상 메서드와 상수로만 이루어져 있다. 때문에 인스턴스를 생성할 수도 없다.

클래스에서 인터페이스 구현하기
 - 인터페이스를 클래스가 사용하는 것을 implements예약어로 사용한다.
   ex) public class Calculator implements Calc 
       Calculator클래스는 추상 메서드 4개를 구현하거나, 추상 클래스로 만들어야 한다.

인터페이스의 역할
 - 인터페이스를 구현한 클래스가 어떤 기능의 메서드를 제공하는지 명시하는 것.
 - 인터페이스를 사용하면 다형성을 구현하여 확장성 있는 프로그램을 만들 수 있습니다.

인터페이스 디폴트 메서드와 정적 메서드
 - 자바 8부터는 디폴트 메서드와 정적 메서드 기능을 제공

디폴트 메서드 
 1) 인터페이스에서 구현 코드까지 작성한 메서드 (여러 클래스에서 사용할 메서드가 기능이 같을 경우 활용)
 2) 디폴트 메서드를 선언할 땐 default 예약어를 사용. 최종 하위 클래스에서 재정의(Override)도 가능

정적 메서드
 1) 인스턴스 생성과 상관없이 사용할 수 있는 메서드
 2) static 예약어를 사용. 사용시에는 인터페이스 이름으로 직접 참조하며 사용.


private 메서드
 - 자바 9부터 인터페이스에 private 메서드를 구현할 수 있다. 
 - private 메서드는 인터페이스를 구현한 클래스에서 사용하거나 재정의할 수 없다. 
 - private 메서드는 코드를 구현해야하므로 추상 메서드에 private 예약어를 사용할 수는 없지만, static예약어는 함께 사용할 수 있다.

Object클래스
 - 모든 자바 클래스의 최상위 클래스인 Object 클래스

String 클래스
 - StringBuffer, StringBuilder : 문자열을 연결 할 때 기존에 사용하던 char[]배열이 확장되므로 추가 메모리 사용X. 
 - StringBuffer가 StringBuilder보다 문자열이 안전하게 변경되도록 보장. 실행속도는 StringBuilder이 더 빠름.

Wrapper 클래스
 - Integer클래스 : 정수를 객체형으로 사용할 때
 - Integer 클래스의 메서드
 - intValue() : Integer 클래스 내부의 int 자료형 값 가져올 때
 - valueOf() : 정수나 문자열을 바로 Integer클래스로 반환할 때
 - ParseInt() : 문자열이 어떤 숫자를 나타낼 때 int값으로 반환
 - 오토박싱 : 기본형을 객체형으로 바꾸는 것
   ex) Integer j = 10 (= Integer j = new Integer(10) ) //둘의 타입이 같아 보이지만 사실 둘의 타입은 다르다.
 - 언박싱 : 객체형을 기본형으로 꺼내는 것 //둘 다 컴파일러가 알아서 해 줌
 
Class 클래스
 - Class 클래스는 컴파일된 class파일에 저장된 클래스나 인터페이스 정보를 가져오는 데 사용.

